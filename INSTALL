# /usr/bin/env bash
##############################
# To install run this script #
##############################

set -e

# Set up colors
# Debug variables
DEBUG=false

REPO="${HOME}/.dotfiles"

# Clone the repository into the home directory
if [ ! -d $REPO ]; then
  git clone git@github.com:achew22/dotfiles.git $REPO
fi

# Define helper functions
output() {
  local title="$1"
  shift
  local color="$1"
  shift
  normal=$(tput sgr0)
  local body="$1"
  shift
  
  printf "${color}${title}:${normal} ${body}" "$@"
}
#output "title" "color" "body 1:%s 2:%s" "arg1" "arg2" "arg3"


info() {
  local body="$1"
  shift
  
  printf "$body" "$@"
}
#info 'Test info (%s)\n' "arg1"

log() {
  local body="$1"
  shift
  local pink=$(tput setaf 5)

  output "Log" "$pink" "$body" "$@"
}
#log 'log (%s, %s)' arg1 arg2

debug() {
  if $DEBUG; then
    local body="$1"
    shift
    local blue=$(tput setaf 4)

    output "Debug" "$blue" "$body" "$@"
  fi
}
#debug 'test (%s, %s)\n' arg1 arg2

warn() {
  local body="$1"
  shift
  local yellow=$(tput setaf 3)
  
  output "Warning" "$yellow" "$body" "$@"
}
#warn 'test (%s, %s)\n' arg1 arg2

error() {
  local body="$1"
  shift
  local red=$(tput setaf 1)
  
  output "Error" "$red" "$body" "$@"
}
#error 'Error (%s, %s)\n' arg1 arg2

success() {
  local body="$1"
  shift
  local green=$(tput setaf 2)

  output "Success" "$green" $body "$@"
}
#success 'Success (%s, %s)\n' arg1 arg2

stage() {
  local title=$1
  local columns=40

  declare -i suffix # declare spare an integer
  local suffix=$columns-${#title}-5

  printf "########################################\n"
  printf "# %*s%s%*s #\n" "$prefix" "$title" " " "$suffix"
  printf "########################################\n\n"
}
#stage "My new stage"

act() {
  local cmd=$1
  shift
  
  debug "${cmd} ${@}"
  
  if ! $DEBUG; then
    $cmd "$@"
  else
    warn "NOT RUNNING THE COMMAND!\n"
  fi
}

# Back up existing dotfiles if they exist
link() {
  local src="$REPO/$1" dest="$2"

  # TODO: Figure out what to test on
  #if [[ -e $dest || -d $dest || -s $dest ]]; then
    info 'Backing up %s as %s\n' "$dest" "$dest.bak"
    act mv "$dest" "$dest.bak"
  #fi

  info 'Symlinking %s to %s\n' "$src" "$dest"  
  act ln -s "$src" "$dest"
}
#link ~/.dotfiles/link/gitignore ~/.gitignore 

parse_folder() {
  action=$1
  dir=$2

  for file in "$dir"/*; do
    # TODO(achew22): Should this only parse files or are folders ok?
    if [[ -f "$file" ]]; then
      basename=$(basename $file)
      $action $file ~/.$basename
    fi
  done
}
#parse_folder echo $HOME

install_vundle() {
  if [[ ! -d ~/.vim/bundle/vundle ]]; then
    info "Cloning vundle\n"
    mkdir -p ~/.vim/bundle

    # Clone the vundle repo
    git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
  fi

  info "Installing vundle plugins this will take a minute\n"

  # Run vim in silent and install the vundle plugins eating output
  if ! $DEBUG; then
    vim -e +BundleInstall +qall > /dev/null 2>&1
    if [[ $? ]]; then
      error 'Vundle install failed. Run :BundleInstall in vim to finish\n'
    fi
  fi
  info "Done installing vundle!\n"
}

stage "Creating linked config files"
parse_folder link "link"

stage "Creating local versions of config files"
touch ${HOME}/.vimrc_local
touch ${HOME}/.bashrc_local

stage "Installing vundle"
install_vundle

stage "Running post install scripts"
parse_folder bash "post_install"

success "Finished\n"
